<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Go核心篇章-Map原理 | Zero(˶˚ ᗨ ˚˶)</title><meta name="author" content="Zero"><meta name="copyright" content="Zero"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言Map是一种很常见的数据结构，在各种语言都有Map的实现，整体上的宏观流程非常相似，但实现细节和精髓百花齐放。 本文主要针对Go中内置的map类型深入学习。   基本用法概述Map又称字典，是一种经典的数据结构，它有如下特点:  存储基于Key-Value结构的映射元素l; 基于Key维度实现数据的去重，保证Key的唯一性; 读取、写入、删除操作时间复杂度o(1);  初始化map 的初始化">
<meta property="og:type" content="article">
<meta property="og:title" content="Go核心篇章-Map原理">
<meta property="og:url" content="https://zlx2019.github.io/article/c8a2cfce.html">
<meta property="og:site_name" content="Zero(˶˚ ᗨ ˚˶)">
<meta property="og:description" content="前言Map是一种很常见的数据结构，在各种语言都有Map的实现，整体上的宏观流程非常相似，但实现细节和精髓百花齐放。 本文主要针对Go中内置的map类型深入学习。   基本用法概述Map又称字典，是一种经典的数据结构，它有如下特点:  存储基于Key-Value结构的映射元素l; 基于Key维度实现数据的去重，保证Key的唯一性; 读取、写入、删除操作时间复杂度o(1);  初始化map 的初始化">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zlx2019.github.io/img/logo/Go-logo.png">
<meta property="article:published_time" content="2023-08-01T06:40:29.000Z">
<meta property="article:modified_time" content="2023-08-15T08:30:27.479Z">
<meta property="article:author" content="Zero">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zlx2019.github.io/img/logo/Go-logo.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zlx2019.github.io/article/c8a2cfce.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Go核心篇章-Map原理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-15 16:30:27'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><link rel="stylesheet" href="/css/bcustom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">135</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">57</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">38</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-home"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-home"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-rili"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-rili"></use></svg><span> 归档</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><i class="fa-fw icon-biaoqian"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-biaoqian"></use></svg><span> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw icon-fenlei"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenlei"></use></svg><span> 分类</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><i class="fa-fw fas fa-list faa-tada"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-yinle"></use></svg><span> 音乐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/movies/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili"></use></svg><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw icon-zuopinzhanshi"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zuopinzhanshi"></use></svg><span> 个人项目</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-guanyuwo"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guanyuwo"></use></svg><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/logo/Go-logo.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Zero(˶˚ ᗨ ˚˶)"><span class="site-name">Zero(˶˚ ᗨ ˚˶)</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-home"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-home"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-rili"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-rili"></use></svg><span> 归档</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><i class="fa-fw icon-biaoqian"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-biaoqian"></use></svg><span> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw icon-fenlei"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenlei"></use></svg><span> 分类</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><i class="fa-fw fas fa-list faa-tada"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-yinle"></use></svg><span> 音乐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/movies/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili"></use></svg><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw icon-zuopinzhanshi"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zuopinzhanshi"></use></svg><span> 个人项目</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-guanyuwo"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guanyuwo"></use></svg><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Go核心篇章-Map原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-01T06:40:29.000Z" title="发表于 2023-08-01 14:40:29">2023-08-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-15T08:30:27.479Z" title="更新于 2023-08-15 16:30:27">2023-08-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Go/">Go</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>27分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Go核心篇章-Map原理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/logo/Go-logo14.jpeg" style="zoom:50%;"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><u>前言</u></h1><p>Map是一种很常见的数据结构，在各种语言都有Map的实现，整体上的宏观流程非常相似，但实现细节和精髓百花齐放。</p>
<p>本文主要针对Go中内置的<code>map</code>类型深入学习。</p>
<hr>

<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a><u><strong>基本用法</strong></u></h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Map又称字典，是一种经典的数据结构，它有如下特点:</p>
<ol>
<li>存储基于Key-Value结构的映射元素l;</li>
<li>基于Key维度实现数据的去重，保证Key的唯一性;</li>
<li>读取、写入、删除操作时间复杂度o(1);</li>
</ol>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><u>初始化</u></h2><p>map 的初始化方式有以下几种:</p>
<ol>
<li><p>通过<code>make()</code>函数分配内存，并且指定初始容量大小;</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">maps <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>通过<code>make()</code>函数初始化,使用默认的容量;</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">maps <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>使用<code>{}</code>直接初始化并且赋值;</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">maps <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span>
  <span class="token string">"z"</span><span class="token punctuation">:</span> <span class="token string">"zhangsan"</span><span class="token punctuation">,</span>
  <span class="token string">"l"</span><span class="token punctuation">:</span> <span class="token string">"lisi"</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p>Map 中,Value的数据类型是没有限制的,但是Key的类型必须为可比较的类型,如<code>slice</code>、<code>map</code>、<code>func</code>等类型无法作为Key使用。</p>
<h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a><u>读取</u></h2><p>读取一个 map 的元素时，可以使用Key直接读取。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">value <span class="token operator">:=</span> maps<span class="token punctuation">[</span><span class="token string">"z"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>倘若 map 没有初始化，或者对应的Key不存在时,则会返回Value类型的零值。</p>
<p>可以通过多返回值得到一个<code>bool</code>类型的返回值,该值决定了是否读取到值。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">value<span class="token punctuation">,</span>ok <span class="token operator">:=</span> maps<span class="token punctuation">[</span><span class="token string">"l"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="写入"><a href="#写入" class="headerlink" title="写入"></a><u>写入</u></h2><p>写操作的语法如下,需要注意的时，如果 map 未初始化就往 map 中写数据则会产生panic。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">maps<span class="token punctuation">[</span><span class="token string">"z"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"张三"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a><u>删除</u></h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token function">delete</span><span class="token punctuation">(</span>maps<span class="token punctuation">,</span><span class="token string">"z"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>执行 delete 方法时，倘若 key 存在，则会从 map 中将对应的 key-value 对删除；倘若 key 不存在或 map 未初始化，则方法直接结束，不会产生显式提示.</p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a><u>遍历</u></h2><p><code>map</code> 可以直接通过<code>for range</code>进行遍历。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span> key<span class="token punctuation">,</span>value <span class="token keyword">range</span> maps<span class="token punctuation">{</span>
  
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>遍历的顺序是无序的。</p>
<h2 id="非并发安全"><a href="#非并发安全" class="headerlink" title="非并发安全"></a><u>非并发安全</u></h2><p>需要注意的是,<code>map</code>不是并发安全的数据结构,若对<code>map</code>进行并发读写操作,会抛出 <code>fatal error</code>，导致程序直接崩溃.</p>
<p>具体规则如下:</p>
<ol>
<li>可以并发读，读取操作是具有幂等性的，它不会对数据进行修改，所以可以随便读取;</li>
<li>所谓的并发<code>读写</code>是广义上的，具体指写入、修改、删除等操作;</li>
</ol>
<p>这里的<code>fatal error</code>是一种比<code>panic</code>更严重的错误,是无法使用<code>recover</code>捕获的;</p>
<hr>

<h1 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a><u>核心原理</u></h1><p>map 又称为 hash map，它依赖于hash算法实现key的映射和寻址；其内部的数据结构是由一个桶数组+链表的形式所存储。</p>
<p>将一个元素插入map的大致流程: </p>
<ol>
<li>通过hash算法得出key的hash值;</li>
<li>使用key的hash值对桶数组进行取模运算，得出一个索引值，该索引值就是元素所归属的桶位置;</li>
<li>将元素追加到桶数组的链表中;</li>
</ol>
<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a><u>hash</u></h2><p>哈希(hash)又称为散列，是一种将任意长度的输入，经过算法计算后压缩为一个固定长度的输出过程。这个输出数据一般称之为哈希值或者散列值。</p>
<p>该过程属于压缩映射，输入空间远大于输出空间，因此不同输入可能会映射成相同的输出。</p>
<p>此外，hash在压缩过程中会存在部分信息的丢失，因此这种压缩过程具有不可逆特性。</p>
<p>hash的特点:</p>
<ul>
<li>相同的输入经过计算后得到相同的输出。</li>
<li>不同的输入经过计算后，很大概率会得到不同的输出，但不能保证一定不同，所以存在hash冲突。</li>
<li>较为相似的输入经过计算后，输出的hash值也会均为地离散化，尽可能避免hash冲突的发生。</li>
</ul>
<p>比如Java中<code>Object</code>类的<code>hashCode()</code>方法，本质上就是一个哈希算法，它固定输出为一个4字节的int整数。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/common/hash.png" style="zoom:100%;"></p>
<h2 id="bucket-array"><a href="#bucket-array" class="headerlink" title="bucket array"></a><u>bucket array</u></h2><p>在map中，核心是使用<strong>数组</strong>  + <strong>链表</strong>的结构来存储 Key-Value 元素，其中数组中的每一个索引位称之为桶,所以称之为桶数组(bucket array)。</p>
<ol>
<li>桶数组的长度固定为2的整数次幂;</li>
<li>每个桶固定可以存放8个 Key-Value元素，并且这8个元素的内存空间是连续的;</li>
<li>如果超过8个元素，写入到同一个桶内，会通过链表的方式来存储;</li>
</ol>
<p>每个元素会通过hash算法得到一个散列化的哈希值，使用该值对桶数组的长度进行取模，得出的索引位则就是元素所存储的桶位。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/common/map-桶数组.png" style="zoom:50%;"></p>
<h2 id="hash冲突"><a href="#hash冲突" class="headerlink" title="hash冲突"></a><u>hash冲突</u></h2><p>哪怕hash值再怎么散列化，但最终都是要对桶数组长度进行取模，从而坐落在其中一个桶，但是由于桶的数量有限，而元素的数量是不确定的，所以将多个元素塞入到同一个桶中是一种必要的手段。</p>
<h3 id="1-拉链法"><a href="#1-拉链法" class="headerlink" title="1.拉链法"></a><u>1.拉链法</u></h3><p>一种常见的解决方法就是使用链表: </p>
<blockquote>
<p>桶数组中的每一个桶存储的元素为8个，每个桶内的元素内存空间都是连续的，当一个桶已满之后再有新的元素插入进来，会形成一个新的桶并且以指针的形式指向它，将新的元素插入的这个新桶内，形成一种<strong>链表结构</strong>。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/common/map-hash拉链法.png" style="zoom:50%;"></p>
<h3 id="2-开放寻址法"><a href="#2-开放寻址法" class="headerlink" title="2.开放寻址法"></a><u>2.开放寻址法</u></h3><blockquote>
<p>开放寻址法是在插入元素时，如果发生hash冲突，但是此时还有未使用的桶位，则将元素放入到未使用的桶位中。尽可能的让所有的桶位都得到充分的利用。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/common/map-开放寻址法.png" style="zoom:100%;"></p>
<p>Golang中的map,在解决hash冲突中，实现结合了以上两种方案的思路，以写入元素流程为例:</p>
<ol>
<li>桶数组中的每一个索引位中的元素,严格意义上就是一个桶链表(bucket linked)，以指针的方式进行串联，这里就体现了拉链法;</li>
<li>每个桶节点(bucket node)只能存放8个元素;</li>
<li>当元素的key通过hash取模之后命中索引位后，会根据开放寻址法，在这个索引位的第一个桶节点中的8个位置寻找一个空位进行写入;</li>
<li>如果当前的桶节点的8个位置已被占满，则根据指针找到下一个桶节点，重复第3步操作;</li>
<li>如果追寻到当前桶位的最后一个桶节点，还是没有找到空位，则创建一个新的通节点追加到桶链表尾部，并且插入新的元素;</li>
</ol>
<h2 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a><u>扩容机制</u></h2><p>随着元素的不断增加，桶数组中的桶节点会越来越多，当元素到达一定的级别，此时操作的时间复杂度会趋于线性.</p>
<p>因此map的桶数组长度会随着元素的增加而进行扩容，以保证每个桶中的元素数量始终均匀的控制在常量级别，满足操作为o(1)的时间复杂度.</p>
<p>扩容分为两种:</p>
<ul>
<li><p><strong>等量扩容</strong></p>
<p>假如我们一开始不停的插入元素，导致桶节点不断的新增，链表不断的增长，但是我们后续又执行了大量移除操作，那么此时就可能会出现桶链表很长，但是每个桶节点都有大量的空位没有被元素占有，导致内存泄露，此时就需要进行等量扩容: 将元素进行迁移，填补到之前的空位，借此减少桶节点的数量;</p>
<p>当桶节点中的溢出桶(链表的桶节点)大于等于 2^B(B为桶数组长度)时，会触发等量扩容，桶数组的长度保持为原值;</p>
</li>
<li><p><strong>增量扩容</strong></p>
<p>将桶数组长度扩容为原来的两倍,并且完成元素的迁移;</p>
<p>当负载因子超过6.5(元素总量 / 桶数组长度 &gt; 6.5)会触发增量扩容;</p>
</li>
</ul>
<p>Go对于map的扩容采用的是<strong>渐进式扩容</strong>，扩容时会创建一个新的桶数组，并且不会立即丢弃旧的桶数组，而是会每次写操作时将一批元素同时迁移到新的桶数组中，将一次迁移拆分为多次，避免因为一次性全量元素的迁移引发性能抖动;</p>
<hr>

<h1 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a><u>源码解读</u></h1><p>源码位于<code>runtime/map.go</code></p>
<h2 id="hmap"><a href="#hmap" class="headerlink" title="hmap"></a><u>hmap</u></h2><p>map的核心结构如下:</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> hmap <span class="token keyword">struct</span> <span class="token punctuation">{</span>
  <span class="token comment">// 当前存储的k-v元素总数量，使用len()函数获取该值</span>
  count     <span class="token builtin">int</span>
  <span class="token comment">// 用于存储一些标志位，用于表示哈希表的状态和特性。</span>
  flags     <span class="token builtin">uint8</span>
  <span class="token comment">// 桶数组长度的次幂指数，当前桶数组长度 = 2^B</span>
  B         <span class="token builtin">uint8</span>
  <span class="token comment">// 表示溢出桶的数量预估值，每个桶数组中除了首个桶节点之外的桶节点被称为溢出桶。</span>
  noverflow <span class="token builtin">uint16</span>
  <span class="token comment">// hash种子，哈希种子在计算哈希值时使用，有助于增加哈希函数的随机性，减少哈希冲突。</span>
  hash0     <span class="token builtin">uint32</span>
  <span class="token comment">// 指向桶数组的指针。</span>
  buckets    unsafe<span class="token punctuation">.</span>Pointer
  <span class="token comment">// 在扩容时会使用新的桶数组来代替旧的桶数组。这个字段用于存储旧的桶数组的指针。</span>
  oldbuckets unsafe<span class="token punctuation">.</span>Pointer
  <span class="token comment">// 表示正在进行迁移的桶(bucket)的进度计数器，这个字段用于跟踪迁移的进度。</span>
  nevacuate  <span class="token builtin">uintptr</span> 
  <span class="token comment">// 预先分配好的溢出桶</span>
  extra <span class="token operator">*</span>mapextra
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>count: map中的元素总数;</li>
<li>flags: 状态标志位，可以标识出 map 是否被 goroutine 并发读写;</li>
<li>B: 桶数组长度的次幂指数，当前桶数组长度为: 2^B，假设B=3,那么长度则为 2^3 = 8；</li>
<li>noverflow：map中溢出桶的数量;</li>
<li>hash0: hash随机因子，生成key的hash值时会用到;</li>
<li>buckets: 桶数组指针;</li>
<li>oldbuckets: 扩容过程中的旧桶数组;</li>
<li>nevacuate: 扩容时的进度标识，旧桶数组中 index 小于 nevacuate 的桶都已经由老桶转移到新桶中；</li>
<li>extra: 预申请的溢出桶，利用空间换时间的方式预先申请一些溢出桶，在后续用到的时候直接使用即可，无需再分配;</li>
</ul>
<h2 id="mapextra"><a href="#mapextra" class="headerlink" title="mapextra"></a><u>mapextra</u></h2><p>map的附加信息结构，在map初始化时，如果容量过大，会提前申请好一批溢出桶，这部分溢出桶存放在<code>mapextra</code>中;</p>
<p><code>mapextra</code>结构如下:</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> mapextra <span class="token keyword">struct</span> <span class="token punctuation">{</span>
  <span class="token comment">// 为桶数组提供的溢出桶列表</span>
	overflow    <span class="token operator">*</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>bmap
  <span class="token comment">// 为扩容时的旧桶数组提供的溢出桶列表</span>
	oldoverflow <span class="token operator">*</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>bmap
  
	<span class="token comment">// 下一个可用的溢出桶</span>
	nextOverflow <span class="token operator">*</span>bmap
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>bmap</code>结构就是桶数组(buckets)中的桶节点,下面我们会介绍到;</p>
<ul>
<li>overflow: 为桶数组(buckets)提供的溢出桶列表;</li>
<li>oldoverflow: 扩容流程中，为旧的桶数组(oldbuckets)提供的溢出桶列表;</li>
<li>nextOverflow: 下一个可用的溢出桶;</li>
</ul>
<h2 id="bmap"><a href="#bmap" class="headerlink" title="bmap"></a><u>bmap</u></h2><p>bmap用于标识map中的桶bucket，其中存储了元素、元素的哈希值的高8位以及溢出桶指针等信息;</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 值为8,标识每个桶只能存8对元素</span>
bucketCnt <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> bucketCntBits

<span class="token keyword">type</span> bmap <span class="token keyword">struct</span> <span class="token punctuation">{</span>
  <span class="token comment">// 元素key的高8为hash值数组，长度固定为8</span>
  tophash <span class="token punctuation">[</span>bucketCnt<span class="token punctuation">]</span><span class="token builtin">uint8</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>该结构就是map中具体的桶bucket结构，可以存储8组元素，以及一个指向下一个溢出桶的指针;</li>
<li>每组元素不止包含key和value，还有key高8位hash值(tophash);</li>
<li>这里代码层面只有tophash列表，是因为key和value的类型是固定的，所以所占字节大小也是固定的，并且桶内的元素内存空间也是连续的，所以完全可以通过内存地址偏移的方式来进行找到后续的元素以及溢出桶的指针;</li>
</ul>
<p>为了方便理解，可以如下理解bmap桶的结构:</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> bmap <span class="token keyword">struct</span> <span class="token punctuation">{</span>
  <span class="token comment">// 元素hash值数组</span>
  tophash <span class="token punctuation">[</span>bucketCnt<span class="token punctuation">]</span><span class="token builtin">uint8</span>
  <span class="token comment">// 元素key数组</span>
  keys <span class="token punctuation">[</span>bucketCnt<span class="token punctuation">]</span>T
  <span class="token comment">// 元素value数组</span>
  values <span class="token punctuation">[</span>bucketCnt<span class="token punctuation">]</span>T
  <span class="token comment">// 溢出桶指针</span>
  overflow <span class="token builtin">uint8</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>

<h2 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a><u>初始化流程</u></h2><p>初始化map流程如下:</p>
<ol>
<li>计算指定的预分配容量大小所需要的内存大小，是否太大会产生内存溢出，如果太大则将预分配容量重置为0;</li>
<li>通过<code>new()</code>函数初始化map结构;</li>
<li>获取hash随机因子;</li>
<li>根据预分配容量，计算取得一个合理的桶数组长度次幂指数(B)，起始为0，不断递增直到递增到一个合理的数值，满足<code>hint &lt;= (1 &lt;&lt; B)</code>;</li>
<li>判断根据上一步计算得出的指数B，是否为0，如果为0则表示<code>hint</code>&lt; 8,只需要1个桶即可,直接返回无需分配桶数组;</li>
<li>初始化桶数组，并且根据B的指数判断是否预先分配好溢出桶，如果B &gt;= 4,就预先分配好溢出桶;</li>
</ol>
<p>创建 map 时，实际上会调用<code>makemap()</code>方法,源码如下:</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// map 初始化函数</span>
<span class="token comment">// t map类型</span>
<span class="token comment">// hint 预期的map容量</span>
<span class="token comment">// h 一个可选的旧map,可以是nil</span>
<span class="token keyword">func</span> <span class="token function">makemap</span><span class="token punctuation">(</span>t <span class="token operator">*</span>maptype<span class="token punctuation">,</span> hint <span class="token builtin">int</span><span class="token punctuation">,</span> h <span class="token operator">*</span>hmap<span class="token punctuation">)</span> <span class="token operator">*</span>hmap <span class="token punctuation">{</span>
  <span class="token comment">// 1. 计算map所需的内存大小</span>
  mem<span class="token punctuation">,</span> overflow <span class="token operator">:=</span> math<span class="token punctuation">.</span><span class="token function">MulUintptr</span><span class="token punctuation">(</span><span class="token function">uintptr</span><span class="token punctuation">(</span>hint<span class="token punctuation">)</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span>bucket<span class="token punctuation">.</span>size<span class="token punctuation">)</span>
  <span class="token comment">// 如果内存溢出、或者计算的内存大小发生了溢出，将容量重置为0</span>
  <span class="token keyword">if</span> overflow <span class="token operator">||</span> mem <span class="token operator">&gt;</span> maxAlloc <span class="token punctuation">{</span>
    hint <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 如果可选的map为nil,则创建map</span>
  <span class="token comment">// 2. 通过new()函数，初始化map</span>
  <span class="token keyword">if</span> h <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
    h <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>hmap<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 3. 获取一个hash随机因子，对于key生成hash值都要用到</span>
  h<span class="token punctuation">.</span>hash0 <span class="token operator">=</span> <span class="token function">fastrand</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token comment">// 4. 计算桶数组长度次幂指数,默认为0,2^0</span>
  B <span class="token operator">:=</span> <span class="token function">uint8</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token comment">//  需要根据给定的hint容量，得出一个合适的指数</span>
  <span class="token comment">//  迭代递增B指数，直到 hint &lt;= 桶数组长度(2 ^ B)</span>
  <span class="token comment">// 	使用overLoadFactor()函数，判断当前次幂指数B与预分配容量是否合适，如果不合适则迭代递增指数，直到找到一个合适的指数</span>
  <span class="token keyword">for</span> <span class="token function">overLoadFactor</span><span class="token punctuation">(</span>hint<span class="token punctuation">,</span> B<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    B<span class="token operator">++</span>
  <span class="token punctuation">}</span>
  h<span class="token punctuation">.</span>B <span class="token operator">=</span> B
  h<span class="token punctuation">.</span>B <span class="token operator">=</span> B

  <span class="token comment">// 5. 如果桶数组长度大于0，则需要初始化桶数组</span>
  <span class="token keyword">if</span> h<span class="token punctuation">.</span>B <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> nextOverflow <span class="token operator">*</span>bmap
    <span class="token comment">// 初始化一个buckets(桶数组),赋值给刚初始化的map,并且可能会预先分配好溢出桶</span>
    h<span class="token punctuation">.</span>buckets<span class="token punctuation">,</span> nextOverflow <span class="token operator">=</span> <span class="token function">makeBucketArray</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> h<span class="token punctuation">.</span>B<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> nextOverflow <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果溢出桶已经预先分配好，初始化extra属性</span>
      h<span class="token punctuation">.</span>extra <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>mapextra<span class="token punctuation">)</span>
      <span class="token comment">// 将分配好的溢出桶，指向下一个可用的溢出桶</span>
      h<span class="token punctuation">.</span>extra<span class="token punctuation">.</span>nextOverflow <span class="token operator">=</span> nextOverflow
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> h
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="overLoadFactor"><a href="#overLoadFactor" class="headerlink" title="overLoadFactor"></a>overLoadFactor</h3><p>通过overLoadFactor方法，对 map 的预分配容量和桶数组的长度进行判断是否合理，这决定是否继续增加桶数组的长度B:</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">const</span> loadFactorNum <span class="token operator">=</span> <span class="token number">13</span>
<span class="token keyword">const</span> loadFactorDen <span class="token operator">=</span> <span class="token number">2</span>
<span class="token keyword">const</span> goarch<span class="token punctuation">.</span>PtrSize <span class="token operator">=</span> <span class="token number">8</span>
<span class="token keyword">const</span> bucketCnt <span class="token operator">=</span> <span class="token number">8</span>

<span class="token comment">// 判断当前次幂指数B,对应的桶数组长度(1&lt;&lt;B)是否超过负载因子6.5</span>
<span class="token comment">// 如果 count &lt;= 桶数组长度(1&lt;&lt;B) * 6.5，则表示指数B合理，返回true;</span>
<span class="token keyword">func</span> <span class="token function">overLoadFactor</span><span class="token punctuation">(</span>count <span class="token builtin">int</span><span class="token punctuation">,</span> B <span class="token builtin">uint8</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> count <span class="token operator">&gt;</span> bucketCnt <span class="token operator">&amp;&amp;</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span> <span class="token operator">&gt;</span> loadFactorNum<span class="token operator">*</span><span class="token punctuation">(</span><span class="token function">bucketShift</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token operator">/</span>loadFactorDen<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 根据次幂指数B，获取桶数组具体的长度, 1 &lt;&lt; B</span>
<span class="token keyword">func</span> <span class="token function">bucketShift</span><span class="token punctuation">(</span>b <span class="token builtin">uint8</span><span class="token punctuation">)</span> <span class="token builtin">uintptr</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>b <span class="token operator">&amp;</span> <span class="token punctuation">(</span>goarch<span class="token punctuation">.</span>PtrSize<span class="token operator">*</span><span class="token number">8</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol>
<li>如果map预分配容量 &lt; 8(bucketCnt)，意味着一个bucket就足够存放元素，所以直接返回true，B取0即可，表示桶长度为1;</li>
<li><p>保证 map 预分配容量小于等于桶数组长度(2^B) * 6.5;</p>
</li>
<li><p>如<code>make(map[int]int,50)</code>预期值为50，则B=3，公式为: 50 &lt;= 52(2^3 * 6.5);</p>
</li>
</ol>
<p>map的预分配容量、B指数、长度增长关系如下表:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>预分配容量</strong></th>
<th><strong>桶数组长度指数 B</strong></th>
<th><strong>桶数组长度 2^B</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>0 ~ 8</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>9 ~ 13</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>14 ~ 26</td>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>27 ~ 52</td>
<td>3</td>
<td>8</td>
</tr>
<tr>
<td>2^(B-1) <em> 6.5+1 ~ 2^B</em>6.5</td>
<td>B</td>
<td>2^B</td>
</tr>
</tbody>
</table>
</div>
<h3 id="makeBucketArray"><a href="#makeBucketArray" class="headerlink" title="makeBucketArray"></a>makeBucketArray</h3><p>通过makeBucketArray方法完成桶数组以及溢出桶初始化</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">makeBucketArray</span><span class="token punctuation">(</span>t <span class="token operator">*</span>maptype<span class="token punctuation">,</span> b <span class="token builtin">uint8</span><span class="token punctuation">,</span> dirtyalloc unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> <span class="token punctuation">(</span>buckets unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">,</span> nextOverflow <span class="token operator">*</span>bmap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取桶数组长度,base表示桶数组的长度(不包含溢出桶)</span>
  base <span class="token operator">:=</span> <span class="token function">bucketShift</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
  <span class="token comment">// 通过 nbuckets 记录累加上溢出桶后，桶数组的总长度.</span>
  nbuckets <span class="token operator">:=</span> base
  <span class="token comment">// 当 B &gt;=4 时(此时的桶数组长度将会 &gt;=52)，会提前创建好溢出桶</span>
  <span class="token keyword">if</span> b <span class="token operator">&gt;=</span> <span class="token number">4</span> <span class="token punctuation">{</span>
    <span class="token comment">// 加上溢出桶的总长度</span>
    nbuckets <span class="token operator">+=</span> <span class="token function">bucketShift</span><span class="token punctuation">(</span>b <span class="token operator">-</span> <span class="token number">4</span><span class="token punctuation">)</span>
    sz <span class="token operator">:=</span> t<span class="token punctuation">.</span>bucket<span class="token punctuation">.</span>size <span class="token operator">*</span> nbuckets
    up <span class="token operator">:=</span> <span class="token function">roundupsize</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span>
    <span class="token keyword">if</span> up <span class="token operator">!=</span> sz <span class="token punctuation">{</span>
      nbuckets <span class="token operator">=</span> up <span class="token operator">/</span> t<span class="token punctuation">.</span>bucket<span class="token punctuation">.</span>size
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 调用 newarray 方法为桶数组申请内存空间，连带着需要初始化的溢出桶：</span>
  <span class="token keyword">if</span> dirtyalloc <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
    buckets <span class="token operator">=</span> <span class="token function">newarray</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>bucket<span class="token punctuation">,</span> <span class="token function">int</span><span class="token punctuation">(</span>nbuckets<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    buckets <span class="token operator">=</span> dirtyalloc
    size <span class="token operator">:=</span> t<span class="token punctuation">.</span>bucket<span class="token punctuation">.</span>size <span class="token operator">*</span> nbuckets
    <span class="token keyword">if</span> t<span class="token punctuation">.</span>bucket<span class="token punctuation">.</span>ptrdata <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
      <span class="token function">memclrHasPointers</span><span class="token punctuation">(</span>buckets<span class="token punctuation">,</span> size<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token function">memclrNoHeapPointers</span><span class="token punctuation">(</span>buckets<span class="token punctuation">,</span> size<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 说明需要创建溢出桶，会基于地址偏移的方式，通过 nextOverflow 指向首个溢出桶的地址.</span>
  <span class="token keyword">if</span> base <span class="token operator">!=</span> nbuckets <span class="token punctuation">{</span>
    nextOverflow <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bmap<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>buckets<span class="token punctuation">,</span> base<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>bucketsize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    last <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bmap<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>buckets<span class="token punctuation">,</span> <span class="token punctuation">(</span>nbuckets<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>bucketsize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    last<span class="token punctuation">.</span><span class="token function">setoverflow</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>bmap<span class="token punctuation">)</span><span class="token punctuation">(</span>buckets<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> buckets<span class="token punctuation">,</span> nextOverflow
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol>
<li>当桶数组的指数 b &gt;= 4时（桶数组的容量 &gt;= 52 ），会需要提前创建溢出桶.</li>
</ol>
<hr>

<h2 id="读取流程"><a href="#读取流程" class="headerlink" title="读取流程"></a><u>读取流程</u></h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/common/go-map读流程.png" style="zoom:100%;"></p>
<p>从map中读取元素的详细流程如下:</p>
<ol>
<li>如果map未初始化，或者当前map内没有元素,则返回元素value类型的零值;</li>
<li>判断map的<code>flags</code>属性是否为<code>hashWriting = 4</code>,如果是，表示此时正常有协程在执行写入操作，此时会抛出<code>fatal</code>使当前程序停止;</li>
<li>根据要查询的key，进行hash运算，得出一个hash值;</li>
<li>根据上一步得出的hash值 对桶数组的索引长度进行取模，得到具体要查询的桶;</li>
<li>判断当前map是否处于扩容中:<ol>
<li>如果处于扩容中，那么再次通过hash值，对旧的桶数组的索引长度进行取模，得到该元素在旧桶数组中所在的桶;</li>
<li>判断这个桶节点是否完成了迁移到了新的桶数组中，如果完成了，则查询第4步得到的新桶节点，如果没有完成则查询上一步得到的旧桶节点;</li>
</ol>
</li>
<li>获取hash值的高8位;</li>
<li>通过双重循环，来遍历桶中的所有节点，以及节点中的8个元素位，来寻找元素，如果最终还是没有找到，则返回value的零值;<ol>
<li>通过第6步得到的hash值，判断与当前元素的tophash是否一致，如果不一致则与下一个元素进行比较;</li>
<li>如果tophash不相等，并且当前元素的tophash为<code>emptyRest</code>，则表示当前节点后续的元素都是空，直接跳出循环，进入下一个节点的遍历;</li>
<li>如果tophash相等，再将查询的key与当前元素的key进行比较，当key也相等时，则表示找到元素，将当前元素的value返回;</li>
</ol>
</li>
</ol>
<p>源码实现如下:</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 根据key获取map中对应的value</span>
<span class="token keyword">func</span> <span class="token function">mapaccess1</span><span class="token punctuation">(</span>t <span class="token operator">*</span>maptype<span class="token punctuation">,</span> h <span class="token operator">*</span>hmap<span class="token punctuation">,</span> key unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> unsafe<span class="token punctuation">.</span>Pointer <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token comment">// 1. 如果map未初始化，或者当前map内没有元素, 直接返回元素的零值以及一个false，表示没有读取到值;</span>
  <span class="token keyword">if</span> h <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token operator">||</span> h<span class="token punctuation">.</span>count <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> t<span class="token punctuation">.</span><span class="token function">hashMightPanic</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      t<span class="token punctuation">.</span><span class="token function">hasher</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// see issue 23734</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>zeroVal<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 2. 根据flags状态值，判断此时是否有其他协程正在执行写入操作，如果有则直接停止进程</span>
  <span class="token keyword">if</span> h<span class="token punctuation">.</span>flags<span class="token operator">&amp;</span>hashWriting <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
    <span class="token function">fatal</span><span class="token punctuation">(</span><span class="token string">"concurrent map read and map write"</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 3. 根据传入的key,进行hash运算，得到一个hash值</span>
  hash <span class="token operator">:=</span> t<span class="token punctuation">.</span><span class="token function">hasher</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>hash0<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token comment">// 4.  根据hash值，对桶数组进行取模，得到一个具体bucket</span>
  <span class="token comment">// 4.1 获取桶数组长度 - 1，获取索引取模范围</span>
  m <span class="token operator">:=</span> <span class="token function">bucketMask</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>B<span class="token punctuation">)</span>
  <span class="token comment">// 4.2 使用hash值对桶数组长度m 进行取模，得到一个桶索引，然后根据索引进行偏移运算，得到具体的桶节点</span>
  b <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bmap<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>buckets<span class="token punctuation">,</span> <span class="token punctuation">(</span>hash<span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>bucketsize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

  <span class="token comment">// 5. 判断map是否处于扩容流程中，如果是则优先从旧桶数组中读取</span>
  <span class="token keyword">if</span> c <span class="token operator">:=</span> h<span class="token punctuation">.</span>oldbuckets<span class="token punctuation">;</span> c <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
    <span class="token comment">// 5.1 判断扩容是否是增量扩容,如果是等量扩容，则不需要变动桶数组索引的长度m;</span>
    <span class="token keyword">if</span> <span class="token operator">!</span>h<span class="token punctuation">.</span><span class="token function">sameSizeGrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果是增量扩容，那么桶数组的索引长度，需要更新为旧的桶数组索引长度</span>
      <span class="token comment">// 假设当前桶数组索引长度m为16，那么旧的桶数组索引长度必定为8(16 &gt;&gt; 1);</span>
      <span class="token comment">// There used to be half as many buckets; mask down one more power of two.</span>
      m <span class="token operator">&gt;&gt;=</span> <span class="token number">1</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 5.2 获取元素在旧桶数组中所存储的桶</span>
    oldb <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bmap<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token punctuation">(</span>hash<span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>bucketsize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment">// 5.3 判断这个桶是否已经完成了迁移,如果完成了迁移，直接读取新的桶即可</span>
    <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">evacuated</span><span class="token punctuation">(</span>oldb<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果没有没有完成，则读取旧桶;</span>
      b <span class="token operator">=</span> oldb
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 6. 获取hash值的高8位，</span>
  top <span class="token operator">:=</span> <span class="token function">tophash</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span>
  bucketloop<span class="token punctuation">:</span>
  <span class="token comment">// 7. 遍历所有的桶中的所有节点，直到找到该元素，如果没有找到，则返回value的零值;</span>
  <span class="token comment">//  遍历桶的每一个节点</span>
  <span class="token keyword">for</span> <span class="token punctuation">;</span> b <span class="token operator">!=</span> <span class="token boolean">nil</span><span class="token punctuation">;</span> b <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">overflow</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 遍历每个桶节点中的元素</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bucketCnt<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> top <span class="token punctuation">{</span>
        <span class="token comment">// 7.1 元素存储时会额外存储key的hash值的高8位，使用该值来比较是要寻找的元素</span>
        <span class="token comment">// 如果tophash不相等</span>
        <span class="token keyword">if</span> b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> emptyRest <span class="token punctuation">{</span>
          <span class="token comment">// 7.2 并且当前元素的tophash为emptyRest的话，则表示后续的元素也都是空，直接跳出当前节点的遍历流程,遍历下一个节点</span>
          <span class="token keyword">break</span> bucketloop
        <span class="token punctuation">}</span>
        <span class="token keyword">continue</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 7.3 tophash相等,但是不一定key是相等的，所以需要进一步比较key值</span>
      <span class="token comment">// 取出当前元素的key值</span>
      k <span class="token operator">:=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token operator">+</span>i<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token keyword">if</span> t<span class="token punctuation">.</span><span class="token function">indirectkey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        k <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 将查找的key与当前元素的key进行比较</span>
      <span class="token keyword">if</span> t<span class="token punctuation">.</span>key<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 比较成功，证明当前元素就是要获取的元素</span>
        <span class="token comment">// 通过内存偏移 获取value的指针,然后返回该指针</span>
        e <span class="token operator">:=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token operator">+</span>bucketCnt<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token operator">+</span>i<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>elemsize<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> t<span class="token punctuation">.</span><span class="token function">indirectelem</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          e <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> e
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// map中不存在该key，返回零值</span>
  <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>zeroVal<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>

<h2 id="写入流程"><a href="#写入流程" class="headerlink" title="写入流程"></a><u>写入流程</u></h2><p>流程图如下:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/common/go-map写流程.png" style="zoom:100%;"></p>
<p>向map中写入元素的流程如下:</p>
<ol>
<li>如果map未初始化，直接<code>panic</code>;</li>
<li>如果<code>flags</code>是否为<code>hashWriting</code>,如果是则表示当前存在其他协程在写入，直接抛出<code>fatal</code>错误;</li>
<li>将<code>flags</code>标记为<code>hashWriting</code>，表示正在写入操作;</li>
<li>如果当前map的桶数组还未初始化，初始化桶数组;</li>
<li>如果当前处于扩容流程，则协助扩容;</li>
<li>遍历所有桶节点和节点中的元素，寻找一个可以存放元素的空位:<ol>
<li>如果当前key已存在，则直接将找到的元素位作为插入位置，后续直接覆盖掉原来的元素;</li>
<li>如果桶节点遍历完还没有找到位置，则分配一个新的溢出桶作为存放位置;</li>
<li>判断是否需要近扩容，如果需要则开始执行扩容流程，并且将元素写入到新的桶数组中;</li>
</ol>
</li>
<li>将插入的元素放入到找到的位置中，将元素数量+1;</li>
<li>插入完成之后，再次校验<code>flags</code>是佛有其他人在并发写，如果有还是会抛出<code>fatal</code>错误;</li>
<li>将<code>hashWriting</code>的标记抹去,并且返回value的指针，写入结束;</li>
</ol>
<p>源码如下:</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 向map中写入一个元素</span>
<span class="token keyword">func</span> <span class="token function">mapassign</span><span class="token punctuation">(</span>t <span class="token operator">*</span>maptype<span class="token punctuation">,</span> h <span class="token operator">*</span>hmap<span class="token punctuation">,</span> key unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> unsafe<span class="token punctuation">.</span>Pointer <span class="token punctuation">{</span>
  <span class="token comment">// 1. 如果map未初始化，则panic;</span>
  <span class="token keyword">if</span> h <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
    <span class="token function">panic</span><span class="token punctuation">(</span><span class="token function">plainError</span><span class="token punctuation">(</span><span class="token string">"assignment to entry in nil map"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">//...</span>
  <span class="token comment">// 2. 如果当前flags已经被标记为了hashWriting,则表示有其他协程在并发写入，直接抛出fatal错误，结束程序</span>
  <span class="token keyword">if</span> h<span class="token punctuation">.</span>flags<span class="token operator">&amp;</span>hashWriting <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
    <span class="token function">fatal</span><span class="token punctuation">(</span><span class="token string">"concurrent map writes"</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 获取key的hash值</span>
  hash <span class="token operator">:=</span> t<span class="token punctuation">.</span><span class="token function">hasher</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>hash0<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token comment">// 3. 将flags 标记为正在写入状态</span>
  h<span class="token punctuation">.</span>flags <span class="token operator">^=</span> hashWriting
  <span class="token comment">// 4. 如果当前map的桶数组buckets 还没有被初始化，则初始化桶数组</span>
  <span class="token keyword">if</span> h<span class="token punctuation">.</span>buckets <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
    h<span class="token punctuation">.</span>buckets <span class="token operator">=</span> <span class="token function">newobject</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>bucket<span class="token punctuation">)</span> <span class="token comment">// newarray(t.bucket, 1)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 开始步入写入流程</span>
  again<span class="token punctuation">:</span>
  <span class="token comment">// 根据hash % 桶数组长度，获取key对应的桶的索引</span>
  bucket <span class="token operator">:=</span> hash <span class="token operator">&amp;</span> <span class="token function">bucketMask</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>B<span class="token punctuation">)</span>
  <span class="token comment">// 5. 如果当前处于扩容中，协助进行扩容;</span>
  <span class="token keyword">if</span> h<span class="token punctuation">.</span><span class="token function">growing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">growWork</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> h<span class="token punctuation">,</span> bucket<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 根据桶的索引，获取到桶节点</span>
  b <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bmap<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>buckets<span class="token punctuation">,</span> bucket<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>bucketsize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token comment">// 获取当前key的高8位</span>
  top <span class="token operator">:=</span> <span class="token function">tophash</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span>
  <span class="token comment">// 6. 寻找空位</span>
  <span class="token comment">// 声明三个指针，用于存放找到的元素的空位</span>
  <span class="token keyword">var</span> inserti <span class="token operator">*</span><span class="token builtin">uint8</span>         <span class="token comment">// 存放元素tophash的地址</span>
  <span class="token keyword">var</span> insertk unsafe<span class="token punctuation">.</span>Pointer <span class="token comment">// 存放元素key的地址</span>
  <span class="token keyword">var</span> elem unsafe<span class="token punctuation">.</span>Pointer    <span class="token comment">// 存放元素的value的地址</span>
  bucketloop<span class="token punctuation">:</span>
  <span class="token comment">// 遍历桶的所有节点</span>
  <span class="token keyword">for</span> <span class="token punctuation">{</span>
    <span class="token comment">// 遍历节点中的所有元素凹槽位(8个)</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bucketCnt<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
      <span class="token comment">// 判断当前元素的tophash与要插入元素的tophash是否相等</span>
      <span class="token keyword">if</span> b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> top <span class="token punctuation">{</span>
        <span class="token comment">// 如果tophash不相等，并且当前元素位为空的话</span>
        <span class="token comment">// 则将插入的元素放入当前槽位</span>
        <span class="token keyword">if</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> inserti <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
          <span class="token comment">// 获取当前元素位的指针地址</span>
          inserti <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
          insertk <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token operator">+</span>i<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token punctuation">)</span>
          elem <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token operator">+</span>bucketCnt<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token operator">+</span>i<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>elemsize<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 如果当前元素位的tophash为emptyRest,则表示后续的元素位全是空，直接跳出</span>
        <span class="token keyword">if</span> b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> emptyRest <span class="token punctuation">{</span>
          <span class="token keyword">break</span> bucketloop
        <span class="token punctuation">}</span>
        <span class="token comment">// 当前空位已有元素，进入下一个元素的循环</span>
        <span class="token keyword">continue</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// tophash相等，则表示可能存在元素重复，所以获取当前元素的key进行比较</span>
      k <span class="token operator">:=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token operator">+</span>i<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token keyword">if</span> t<span class="token punctuation">.</span><span class="token function">indirectkey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        k <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 如果key不相等，进入下一个元素的循环</span>
      <span class="token keyword">if</span> <span class="token operator">!</span>t<span class="token punctuation">.</span>key<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">continue</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// topchash相等 &amp;&amp; key相等，走到这里表示要插入的元素已存在;</span>
      <span class="token comment">// 直接将插入的元素覆盖掉当前元素位</span>
      <span class="token comment">// already have a mapping for key. Update it.</span>
      <span class="token keyword">if</span> t<span class="token punctuation">.</span><span class="token function">needkeyupdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 覆盖元素</span>
        <span class="token function">typedmemmove</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>key<span class="token punctuation">,</span> k<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      elem <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token operator">+</span>bucketCnt<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token operator">+</span>i<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>elemsize<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token comment">// 覆盖后，则无需继续遍历桶节点</span>
      <span class="token comment">// 直接步入到最末尾的收尾操作</span>
      <span class="token keyword">goto</span> done
    <span class="token punctuation">}</span>
    ovf <span class="token operator">:=</span> b<span class="token punctuation">.</span><span class="token function">overflow</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span>
    <span class="token keyword">if</span> ovf <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
      <span class="token keyword">break</span>
    <span class="token punctuation">}</span>
    b <span class="token operator">=</span> ovf
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token operator">!</span>h<span class="token punctuation">.</span><span class="token function">growing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token function">overLoadFactor</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>count<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> h<span class="token punctuation">.</span>B<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">tooManyOverflowBuckets</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>noverflow<span class="token punctuation">,</span> h<span class="token punctuation">.</span>B<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">hashGrow</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> h<span class="token punctuation">)</span>
    <span class="token keyword">goto</span> again
  <span class="token punctuation">}</span>

  <span class="token comment">// 如果走到这里inserti还是为nil，则表示当前桶节点已经占满8个元素了，没有空位可用</span>
  <span class="token keyword">if</span> inserti <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
    <span class="token comment">// 分配一个新的溢出桶</span>
    newb <span class="token operator">:=</span> h<span class="token punctuation">.</span><span class="token function">newoverflow</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
    inserti <span class="token operator">=</span> <span class="token operator">&amp;</span>newb<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    insertk <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>newb<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token punctuation">)</span>
    elem <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>insertk<span class="token punctuation">,</span> bucketCnt<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 走到这里表示已经找到了可存放元素的位置</span>
  <span class="token comment">// 可能是之前被移除后而空闲的位置 || 可能是最后一个溢出桶的末尾位置 || 也可能是新分配的溢出桶</span>
  <span class="token keyword">if</span> t<span class="token punctuation">.</span><span class="token function">indirectkey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    kmem <span class="token operator">:=</span> <span class="token function">newobject</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>key<span class="token punctuation">)</span>
    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span><span class="token punctuation">(</span>insertk<span class="token punctuation">)</span> <span class="token operator">=</span> kmem
    insertk <span class="token operator">=</span> kmem
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> t<span class="token punctuation">.</span><span class="token function">indirectelem</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    vmem <span class="token operator">:=</span> <span class="token function">newobject</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>elem<span class="token punctuation">)</span>
    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span><span class="token punctuation">(</span>elem<span class="token punctuation">)</span> <span class="token operator">=</span> vmem
  <span class="token punctuation">}</span>
  <span class="token comment">// 将 tophash、key、value 插入到取得空位中，并且将 map 的 key-value 对计数器 count 值加 1；</span>
  <span class="token function">typedmemmove</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>key<span class="token punctuation">,</span> insertk<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
  <span class="token operator">*</span>inserti <span class="token operator">=</span> top
  h<span class="token punctuation">.</span>count<span class="token operator">++</span>

  <span class="token comment">// 插入流程完成</span>
  done<span class="token punctuation">:</span>
  <span class="token comment">// 再次检验是否有其他协程在并发写，如果有抛出fatal结束程序;</span>
  <span class="token keyword">if</span> h<span class="token punctuation">.</span>flags<span class="token operator">&amp;</span>hashWriting <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
    <span class="token function">fatal</span><span class="token punctuation">(</span><span class="token string">"concurrent map writes"</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 将hashWriting标记抹去</span>
  h<span class="token punctuation">.</span>flags <span class="token operator">&amp;^=</span> hashWriting
  <span class="token comment">// 获取元素的value地址,并且返回</span>
  <span class="token keyword">if</span> t<span class="token punctuation">.</span><span class="token function">indirectelem</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    elem <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span><span class="token punctuation">(</span>elem<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> elem
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>

<h2 id="删除流程"><a href="#删除流程" class="headerlink" title="删除流程"></a><u>删除流程</u></h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/common/go-map删除流程.png" style="zoom:100%;"></p>
<p>桶节点有8个元素位，用于存放元素的tophash值，每个元素位都会有一个标识，表示是否是空位;</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">emptyRest      <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">// this cell is empty, and there are no more non-empty cells at higher indexes or overflows.</span>
emptyOne       <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment">// this cell is empty</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>emptyOne</code>表示桶节点中的某个槽位是空位;</p>
<p><code>emptyRest</code>表示该槽位的后续槽位全部都是空位;</p>
<p>一个元素位是否为<code>emptyRest</code>就是在删除流程中所决定，这也是删除流程中的核心逻辑;</p>
<p>流程如下:</p>
<ol>
<li>如果map未初始化，或者没有元素，直接结束返回;</li>
<li>如果此时有其他协程在执行写操作，直接抛出fatal;</li>
<li>计算得出key的hash值;</li>
<li>将map标记为<code>hashWriting</code>表示此时正在写操作;</li>
<li>是否处于扩容中，如果是则协助扩容;</li>
<li>找到key对应的桶链表头节点;</li>
<li>遍历桶链表，寻找要删除的元素，并且删除该元素;<ol>
<li>删除元素，并且将当前元素为设置为<code>emptyOne</code>;</li>
<li>判断下一个元素位是否是<code>emptyRest</code>，如果不是则该步骤结束;</li>
<li>如果下一个元素位是<code>emptyRest</code>，则将当前元素位设置为<code>emptyRest</code>;</li>
<li>并且从当前元素位倒序遍历，将该元素位前面是<code>emptyOne</code>的位置设置为<code>emptyRest</code>，直到遍历到有元素的位置结束；</li>
</ol>
</li>
<li>判断是否依然处于<code>hashWriting</code>,如果被破坏了，则抛出fatal;</li>
<li>清除<code>hashWriting</code>标记后正常结束流程;</li>
</ol>
<p>源码如下:</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// map删除元素函数</span>
<span class="token keyword">func</span> <span class="token function">mapdelete</span><span class="token punctuation">(</span>t <span class="token operator">*</span>maptype<span class="token punctuation">,</span> h <span class="token operator">*</span>hmap<span class="token punctuation">,</span> key unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">//  如果未初始化，或者没有元素，直接结束返回;</span>
	<span class="token keyword">if</span> h <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token operator">||</span> h<span class="token punctuation">.</span>count <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> t<span class="token punctuation">.</span><span class="token function">hashMightPanic</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			t<span class="token punctuation">.</span><span class="token function">hasher</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// see issue 23734</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 是否有其他协程在写，如果有直接抛出fatal;</span>
	<span class="token keyword">if</span> h<span class="token punctuation">.</span>flags<span class="token operator">&amp;</span>hashWriting <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
		<span class="token function">fatal</span><span class="token punctuation">(</span><span class="token string">"concurrent map writes"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 得出hash值</span>
	hash <span class="token operator">:=</span> t<span class="token punctuation">.</span><span class="token function">hasher</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>hash0<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token comment">// 添加写标记</span>
	h<span class="token punctuation">.</span>flags <span class="token operator">^=</span> hashWriting

	bucket <span class="token operator">:=</span> hash <span class="token operator">&amp;</span> <span class="token function">bucketMask</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>B<span class="token punctuation">)</span>
	<span class="token comment">// 是否处于扩容中，如果是则协助扩容</span>
	<span class="token keyword">if</span> h<span class="token punctuation">.</span><span class="token function">growing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">growWork</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> h<span class="token punctuation">,</span> bucket<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//  获取key对应的桶链表头部节点</span>
	b <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bmap<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>buckets<span class="token punctuation">,</span> bucket<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>bucketsize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	bOrig <span class="token operator">:=</span> b
	top <span class="token operator">:=</span> <span class="token function">tophash</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span>
	<span class="token comment">// 遍历桶链表，寻找要元素的元素</span>
search<span class="token punctuation">:</span>
	<span class="token keyword">for</span> <span class="token punctuation">;</span> b <span class="token operator">!=</span> <span class="token boolean">nil</span><span class="token punctuation">;</span> b <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">overflow</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bucketCnt<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
			<span class="token keyword">if</span> b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> top <span class="token punctuation">{</span>
				<span class="token keyword">if</span> b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> emptyRest <span class="token punctuation">{</span>
					<span class="token comment">// 如果当前元素位是emptyRest，直接跳出当前桶节点</span>
					<span class="token keyword">break</span> search
				<span class="token punctuation">}</span>
				<span class="token keyword">continue</span>
			<span class="token punctuation">}</span>
			<span class="token comment">// 获取当前元素的key</span>
			k <span class="token operator">:=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token operator">+</span>i<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token punctuation">)</span>
			k2 <span class="token operator">:=</span> k
			<span class="token keyword">if</span> t<span class="token punctuation">.</span><span class="token function">indirectkey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				k2 <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span><span class="token punctuation">(</span>k2<span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token punctuation">}</span>
			<span class="token comment">// key不相等，跳过</span>
			<span class="token keyword">if</span> <span class="token operator">!</span>t<span class="token punctuation">.</span>key<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> k2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token keyword">continue</span>
			<span class="token punctuation">}</span>
			<span class="token comment">// 找到要删除的元素，进行删除</span>
			<span class="token comment">// Only clear key if there are pointers in it.</span>
			<span class="token keyword">if</span> t<span class="token punctuation">.</span><span class="token function">indirectkey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">nil</span>
			<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> t<span class="token punctuation">.</span>key<span class="token punctuation">.</span>ptrdata <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
				<span class="token function">memclrHasPointers</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> t<span class="token punctuation">.</span>key<span class="token punctuation">.</span>size<span class="token punctuation">)</span>
			<span class="token punctuation">}</span>
			e <span class="token operator">:=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token operator">+</span>bucketCnt<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token operator">+</span>i<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>elemsize<span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token keyword">if</span> t<span class="token punctuation">.</span><span class="token function">indirectelem</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">nil</span>
			<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> t<span class="token punctuation">.</span>elem<span class="token punctuation">.</span>ptrdata <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
				<span class="token function">memclrHasPointers</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> t<span class="token punctuation">.</span>elem<span class="token punctuation">.</span>size<span class="token punctuation">)</span>
			<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
				<span class="token function">memclrNoHeapPointers</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> t<span class="token punctuation">.</span>elem<span class="token punctuation">.</span>size<span class="token punctuation">)</span>
			<span class="token punctuation">}</span>
			<span class="token comment">// 将该元素位设置为emptyOne，表示空位置</span>
			b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> emptyOne
			<span class="token comment">// 判断下一个元素位是否为emptyRest，如果不是则跳过后续遍历。进入下一步</span>
			<span class="token comment">// 如果下一个元素位是emptyRest，则后续遍历，将当前元素~上一个有元素的位置之间的位置全部设置为emptyRest</span>
			<span class="token keyword">if</span> i <span class="token operator">==</span> bucketCnt<span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">{</span>
				<span class="token keyword">if</span> b<span class="token punctuation">.</span><span class="token function">overflow</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> b<span class="token punctuation">.</span><span class="token function">overflow</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">.</span>tophash<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> emptyRest <span class="token punctuation">{</span>
					<span class="token keyword">goto</span> notLast
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
				<span class="token keyword">if</span> b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> emptyRest <span class="token punctuation">{</span>
					<span class="token keyword">goto</span> notLast
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			<span class="token comment">// 后续遍历，将emptyOne的位置，设置为emptyRest，直到遍历到有元素的元素位结束;</span>
			<span class="token keyword">for</span> <span class="token punctuation">{</span>
				b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> emptyRest
				<span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
					<span class="token keyword">if</span> b <span class="token operator">==</span> bOrig <span class="token punctuation">{</span>
						<span class="token keyword">break</span> <span class="token comment">// beginning of initial bucket, we're done.</span>
					<span class="token punctuation">}</span>
					<span class="token comment">// Find previous bucket, continue at its last entry.</span>
					c <span class="token operator">:=</span> b
					<span class="token keyword">for</span> b <span class="token operator">=</span> bOrig<span class="token punctuation">;</span> b<span class="token punctuation">.</span><span class="token function">overflow</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token operator">!=</span> c<span class="token punctuation">;</span> b <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">overflow</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
					<span class="token punctuation">}</span>
					i <span class="token operator">=</span> bucketCnt <span class="token operator">-</span> <span class="token number">1</span>
				<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
					i<span class="token operator">--</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">if</span> b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> emptyOne <span class="token punctuation">{</span>
					<span class="token keyword">break</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		notLast<span class="token punctuation">:</span>
			<span class="token comment">// 元素删除完成，数量-1</span>
			h<span class="token punctuation">.</span>count<span class="token operator">--</span>
			<span class="token keyword">if</span> h<span class="token punctuation">.</span>count <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
				h<span class="token punctuation">.</span>hash0 <span class="token operator">=</span> <span class="token function">fastrand</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">break</span> search
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 判断删除之前设置的hashWriting标记是否被破坏</span>
	<span class="token keyword">if</span> h<span class="token punctuation">.</span>flags<span class="token operator">&amp;</span>hashWriting <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
		<span class="token function">fatal</span><span class="token punctuation">(</span><span class="token string">"concurrent map writes"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 移除hashWriting标记,结束删除</span>
	h<span class="token punctuation">.</span>flags <span class="token operator">&amp;^=</span> hashWriting
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="遍历流程"><a href="#遍历流程" class="headerlink" title="遍历流程"></a><u>遍历流程</u></h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://zlx2019.github.io">Zero</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zlx2019.github.io/article/c8a2cfce.html">https://zlx2019.github.io/article/c8a2cfce.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zlx2019.github.io" target="_blank">Zero(˶˚ ᗨ ˚˶)</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Go/">Go</a></div><div class="post_share"><div class="social-share" data-image="/img/logo/Go-logo.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/reward/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/reward/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/reward/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/reward/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/article/5e8da917.html" title="Gin-源码及原理剖析"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/logo/Gin-logo.webp" onerror="onerror=null;src='/img/loadError.jpeg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Gin-源码及原理剖析</div></div></a></div><div class="next-post pull-right"><a href="/article/d8e2378e.html" title="Go核心篇章-Slice原理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/logo/Go-logo.png" onerror="onerror=null;src='/img/loadError.jpeg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Go核心篇章-Slice原理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/article/5e8da917.html" title="Gin-源码及原理剖析"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/logo/Gin-logo.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-17</div><div class="title">Gin-源码及原理剖析</div></div></a></div><div><a href="/article/905697b5.html" title="Go【三】字符处理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/logo/Go-logo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-28</div><div class="title">Go【三】字符处理</div></div></a></div><div><a href="/article/35aea58a.html" title="Go【七】Channel"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/logo/Go-logo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-09</div><div class="title">Go【七】Channel</div></div></a></div><div><a href="/article/5f275f0a.html" title="Go【二】容器集合"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/logo/Go-logo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-27</div><div class="title">Go【二】容器集合</div></div></a></div><div><a href="/article/efc238b2.html" title="Go【五】文件操作"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/logo/Go-logo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-28</div><div class="title">Go【五】文件操作</div></div></a></div><div><a href="/article/d1f817d2.html" title="Go【八】context"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/logo/Go-logo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-10</div><div class="title">Go【八】context</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Zero</div><div class="author-info__description">欲买桂花同载酒<br/>终不似,少年游</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">135</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">57</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">38</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zlx2019"><i class="fab fa-github"></i><span>前往Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://res.abeim.cn/api/qq/?qq=1143967454" target="_blank" title="QQ"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-QQ"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/397253487" target="_blank" title="BiliBili"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://github.com/zlx2019" target="_blank" title="Github"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-github"></use></svg></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-text">基本用法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96"><span class="toc-text">读取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%85%A5"><span class="toc-text">写入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4"><span class="toc-text">删除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%8D%E5%8E%86"><span class="toc-text">遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8"><span class="toc-text">非并发安全</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-text">核心原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#hash"><span class="toc-text">hash</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bucket-array"><span class="toc-text">bucket array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hash%E5%86%B2%E7%AA%81"><span class="toc-text">hash冲突</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8B%89%E9%93%BE%E6%B3%95"><span class="toc-text">1.拉链法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BC%80%E6%94%BE%E5%AF%BB%E5%9D%80%E6%B3%95"><span class="toc-text">2.开放寻址法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-text">扩容机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB"><span class="toc-text">源码解读</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#hmap"><span class="toc-text">hmap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mapextra"><span class="toc-text">mapextra</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bmap"><span class="toc-text">bmap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B"><span class="toc-text">初始化流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#overLoadFactor"><span class="toc-text">overLoadFactor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#makeBucketArray"><span class="toc-text">makeBucketArray</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B"><span class="toc-text">读取流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B"><span class="toc-text">写入流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%B5%81%E7%A8%8B"><span class="toc-text">删除流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%B5%81%E7%A8%8B"><span class="toc-text">遍历流程</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/article/d6f32c5d.html" title="ANSI控制符"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://movies-bucket.oss-cn-beijing.aliyuncs.com/5bc57fcd37e142589c8e72351700e8c3.jpg" onerror="this.onerror=null;this.src='/img/loadError.jpeg'" alt="ANSI控制符"/></a><div class="content"><a class="title" href="/article/d6f32c5d.html" title="ANSI控制符">ANSI控制符</a><time datetime="2024-04-08T02:20:00.000Z" title="发表于 2024-04-08 10:20:00">2024-04-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/article/23837e8a.html" title="Blender笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/blogCover/default.jpg" onerror="this.onerror=null;this.src='/img/loadError.jpeg'" alt="Blender笔记"/></a><div class="content"><a class="title" href="/article/23837e8a.html" title="Blender笔记">Blender笔记</a><time datetime="2024-04-08T02:18:32.000Z" title="发表于 2024-04-08 10:18:32">2024-04-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/article/d0870925.html" title="我的Debian系统配置"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://movies-bucket.oss-cn-beijing.aliyuncs.com/5092202441e14867a2591de72ec29897.jpg" onerror="this.onerror=null;this.src='/img/loadError.jpeg'" alt="我的Debian系统配置"/></a><div class="content"><a class="title" href="/article/d0870925.html" title="我的Debian系统配置">我的Debian系统配置</a><time datetime="2024-01-20T06:31:42.000Z" title="发表于 2024-01-20 14:31:42">2024-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/article/dec6f8bb.html" title="Go核心篇章-内存管理"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://movies-bucket.oss-cn-beijing.aliyuncs.com/95443c0654a7422fa17e4da7a1e6c493.jpeg" onerror="this.onerror=null;this.src='/img/loadError.jpeg'" alt="Go核心篇章-内存管理"/></a><div class="content"><a class="title" href="/article/dec6f8bb.html" title="Go核心篇章-内存管理">Go核心篇章-内存管理</a><time datetime="2023-11-27T14:41:56.000Z" title="发表于 2023-11-27 22:41:56">2023-11-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/article/5e8da917.html" title="Gin-源码及原理剖析"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/logo/Gin-logo.webp" onerror="this.onerror=null;this.src='/img/loadError.jpeg'" alt="Gin-源码及原理剖析"/></a><div class="content"><a class="title" href="/article/5e8da917.html" title="Gin-源码及原理剖析">Gin-源码及原理剖析</a><time datetime="2023-08-17T11:30:48.000Z" title="发表于 2023-08-17 19:30:48">2023-08-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By Zero</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script async src="//at.alicdn.com/t/c/font_3947604_tesead3g5v.js"></script><div class="aplayer no-destroy" data-id="2658354885" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false"> </div><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.2.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.3.1" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" data-title="本站采用多线部署，主线路托管于Vercel" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel" alt=""/></a><a class="github-badge" target="_blank" href="https://dashboard.4everland.org/" style="margin-inline:5px" data-title="本站采用多线部署，备用线路托管于4EVERLAND" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-4EVERLAND-22DDDD?style=flat&amp;logo=IPFS" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 280px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/about/'|| '/about/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("https://gitcalendar.fomal.cc/api?zlx2019",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'zlx2019')
    }
  </script><!-- hexo injector body_end end --></body></html>